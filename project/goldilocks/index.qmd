---
title: "The Goldilocks Principle"
date: "2020-08-09"
categories: [R, sample distribution, simulation]
description: "Simulating stock portfolio returns inspired by bowls of porridge left by three bears"
image: "feature.gif"
---

![](feature.gif)

[The Goldilocks principle](https://en.wikipedia.org/wiki/Goldilocks_principle) has its origins in a children's story about a girl who tastes the bowls of porridge left by three bears. She prefers the one that is neither too hot nor too cold, but is just right.

When it comes to investing in stocks, how many is "just right"?

```{r}
#| label: libraries

library(tidyverse)
library(wesanderson)
library(scales)
library(truncnorm)
```

I'll use this palette.

```{r}
#| label: theme
#| fig-height: 2
#| dev.args: { bg: "transparent" }

theme_set(theme_bw())

(cols <- wes_palette(name = "Darjeeling2"))
```

Suppose the [average stock market return](https://www.investopedia.com/ask/answers/042415/what-average-annual-return-sp-500.asp) is around 10%. And you do extensive research, burning the midnight oil, poring over stock fundamentals. Or perhaps you develop a cool machine learning model. And you arrive at a list of 50 promising stocks you feel confident would, on average, deliver well-above-market returns.

I'll create some randomly made up stocks with an average return close to 40%. Some will tank due to events one could not foresee; I'll allow some to lose up to 20%. Similarly, some could generate exceptional returns.

```{r}
#| label: synthetic

set.seed(123)

stock_data <- tibble(
  stock = chartr("0123456789", "abcdefghij", sample(50)),
  return = rtruncnorm(50, a = -0.2, mean = 0.4, sd = 0.5)
)

mean(stock_data$return)
```

Here's the resultant distribution I'll use to assess the impact of portfolio size. Stock markets are fairly close to a normal distribution, albeit with fatter tails due to a few extreme outcomes.

```{r}
#| label: distribution

stock_data |> 
  ggplot(aes(return)) +
  geom_histogram(fill = cols[2]) +
  scale_x_continuous(labels = label_percent()) +
  labs(title = "50 Randomly-generated Stock Returns", 
       x = "Annual Return", y = "Count")
```

Now suppose you share 2 stocks, selected at random, with 1,000 of your social network friends (selecting a different pair of stocks for each friend). Will they all still be friends a year later? And if you repeated the same scenario with portfolio sizes of 5, 10, 20 and 50 stocks per person, would that change the outcome? Let's see.

```{r}
#| label: simulate

portfolio <- function(x) {
  stock_data |>
    slice_sample(n = x, replace = TRUE) |>
    summarise(
      portfolio_return = mean(return),
      portfolio_size = x
    ) |>
    bind_rows()
}

set.seed(456)

portfolios <-
  map_dfr(c(
    rep(2, 1000),
    rep(5, 1000),
    rep(10, 1000),
    rep(20, 1000),
    rep(50, 1000)
  ), portfolio) |>
  mutate(portfolio_size = factor(portfolio_size))

mean_returns <- portfolios |>
  group_by(portfolio_size) |>
  summarise(
    mean_return = mean(portfolio_return),
    min_return = min(portfolio_return)
  ) |>
  ungroup()

portfolios |>
  ggplot(aes(portfolio_size, portfolio_return, group = portfolio_size)) +
  geom_violin(aes(fill = portfolio_size), show.legend = FALSE) +
  geom_label(aes(portfolio_size, 1.5,
    label = percent(mean_return, accuracy = 1)
  ),
  data = mean_returns, fill = cols[4],
  ) +
  geom_label(aes(portfolio_size, -0.2,
    label = percent(min_return, accuracy = 1)
  ),
  data = mean_returns, fill = cols[1],
  ) +
  scale_y_continuous(labels = label_percent(), breaks = breaks_extended(9)) +
  scale_fill_manual(values = cols[c(1:5)]) +
  labs(
    x = "Portfolio Size", y = "Return",
    title = "How Portfolio Size Changes Downside & Upside Risk",
    subtitle = "BLUE Labels = Mean Return; BROWN Labels = Worst Return"
  )
```

So, for all portfolio sizes, the average return across your 1,000 friends is around 42%.

But, when the portfolio size is 2, you may be erased from a few Christmas card lists (or worse). If one of those two stocks has an extreme negative outcome, there's little else in the portfolio to dissipate the effect. As the portfolio size increases, the risk (downside and upside) dramatically reduces.

But is more always better? Well, irrespective of whether your list of promising stocks resulted from desk research or a model, there will be a varying degree of confidence in the 50. A machine learning model, for example, would assign class probabilities to each stock.

So by picking a smaller number, one can select those in which one feels most confident, or which have the highest class probability. And by picking a larger number (ideally across different sectors to further reduce risk) one can weaken the effects of a bad egg or two caused by events no research or model could foresee.

So perhaps the answer is to pick a worst-case scenario one would be prepared to accept. In the plot above, accepting a small chance of only a 12% return (still better than the historical average market return), might provide the "just right" portfolio. A portfolio of a manageable size, focused on your highest-confidence stocks, and with pretty good odds of the desired return.

## R Toolbox

Summarising below the packages and functions used in this post enables me to separately create a [toolbox visualisation](/project/box) summarising the usage of packages and functions across all posts.

```{r}
#| label: toolbox
#| echo: false

pckg <- search() |> # Which packages are loaded?
  as_tibble() |>
  filter(str_detect(value, "package:"))

func <- pckg$value |> # What are their functions?
  map(possibly(ls, NA)) |>
  set_names(pckg$value) |>
  enframe("pckg", "func") |>
  unnest() |> 
  filter(func != "date")

reexp <- tribble(
  ~Package, ~func,
  "package:tibble", "as_tibble",
  "package:dplyr", "filter",
  "package:tibble", "tribble",
  "package:tibble", "tibble"
)

# Remove non-code
code_only <- tibble(line = "index.qmd" |>
  str_remove(".*post/") |> read_lines()) |>
  mutate(
    marker = if_else(str_detect(line, "^```"), 1, 0),
    marker = cumsum(marker),
    marker = if_else(marker %% 2 == 0, "comment", "code")
  ) |>
  filter(marker == "code", !str_starts(line, "library")) |>
  mutate(line = str_remove_all(line, "(?<=\")[[:alpha:]]+(?=\")"))

toolkit <- # Which functions are used in the code?
  map2_dfr(func$func, func$pckg, function(i, j) {
    tibble(
      Package = j,
      func = i,
      total = code_only |>
        str_count(str_c("[^$.-_]", "\\b", "\\Q", i, "\\E", "\\b", "(?=\\(|\\))")) |>
        sum()
    )
  }) |>
  filter(total > 0) |>
  arrange(Package, desc(total)) |>
  mutate(
    conflict = if_else(func %in% conflicts(), 1, 0), # Remove conflicts
    Function = str_c(func, "[", total, "]")
  ) |>
  arrange(desc(conflict), func) |> 
  filter(!(conflict == 1 & !str_c(Package, func) %in% str_c(reexp$Package, reexp$func))) |>
  group_by(Package) |>
  summarise(Function = str_c(Function, collapse = ";  ")) |>
  mutate(Package = str_remove(Package, "package:"))

toolkit
```
