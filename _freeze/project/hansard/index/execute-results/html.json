{
  "hash": "ea4956514be72ccc34b548b8ddb3a84e",
  "result": {
    "markdown": "---\ntitle: \"Cluster of Six\"\ndate: \"2018-01-29\"\ncategories: [R, clustering, correlation]\ndescription: \"Exploring parliamentary voting patterns with hierarchical clustering\"\nimage: \"feature.gif\"\nbibliography: references.bib\n---\n\n\n![](feature.gif)\n\nBefore each vote, the Speaker of the House yells \"Division! Clear the Lobby\". I'd like to find which cluster of MPs (Members of Parliament) may be exiting the lobby and going their own way.\n\n[Hansard](https://hansard.parliament.uk) reports what's said in the UK Parliament, sets out details of divisions, and records decisions taken during a sitting. The R package [hansard package](https://cran.r-project.org/web/packages/hansard/) [@hansard] provides access to the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(clock)\nlibrary(wesanderson)\nlibrary(hansard)\nlibrary(dendextend)\nlibrary(corrplot)\nlibrary(broom)\nlibrary(factoextra)\nlibrary(glue)\nlibrary(ggrepel)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_bw())\n\n(cols <- wes_palette(name = \"Moonrise2\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/theme-1.png){width=100%}\n:::\n:::\n\n\nI'll start by building a list of all Labour Party MPs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl_prefix <- \"http://data.parliament.uk/members/\"\n\nmps <- commons_members() |>\n  filter(party_value == \"Labour\" | about == str_c(url_prefix, \"478\")) |>\n  mutate(ID = str_replace(about, url_prefix, \"\"))\n\nsaveRDS(mps, file = \"mps.rds\")\n```\n:::\n\n\n\n\nCreating a function will enable me to iterate through the MP list to extract their voting records.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_date <- \"2017-06-08\"\nend_date <- \"2018-01-28\"\n\npull_votes <- function(x) {\n  mp_vote_record(x,\n    start_date = start_date,\n    end_date = end_date,\n    verbose = FALSE\n  ) |>\n    mutate(mp = x)\n}\n```\n:::\n\n\nI'll use it to extract the \"aye\" and \"no\" votes. Use of `possibly` prevents the code from stopping when it encounters former MPs for whom no data is returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes <-\n  map(mps$ID, possibly(pull_votes, NULL)) |>\n  compact() |>\n  map_dfr(simplify, \"tibbles\") |>\n  rename(\"lobby\" = \"vote\")\n\nsaveRDS(votes, file = \"votes.rds\")\n```\n:::\n\n\n\n\nVoting the opposite way to the majority of the party, as well as non-votes, will both be of interest when assessing which MPs are \"most distant\" from the wider party.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvotes_df <- votes |>\n  left_join(mps, by = c(\"mp\" = \"ID\")) |>\n  select(about = about.x, title, date_value, lobby, mp, name = full_name_value) |>\n  transmute(\n    vote = if_else(lobby == \"aye\", 1, -1),\n    mp = str_c(name, \" (\", mp, \")\"),\n    about = str_replace(about, \"http://data.parliament.uk/resources/\", \"\"),\n    title = str_c(title, \" (\", about, \")\")\n  ) |> \n  select(-about) |> \n  pivot_wider(names_from = title, values_from = vote, values_fill = 0)\n```\n:::\n\n\nThe data are standardised (i.e. scaled) to ensure comparability. This is verified by ensuring the mean and standard deviation are close to zero and one respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_df <-\n  votes_df |>\n  mutate(across(-mp, scale))\n\nscaled_df |>\n  summarise(across(-mp, list(mean = mean, sd = sd))) |>\n  summarise(\n    sd_min = min(c_across(ends_with(\"_sd\"))),\n    sd_max = max(c_across(ends_with(\"_sd\"))),\n    mean_min = min(c_across(ends_with(\"_mean\"))),\n    mean_max = max(c_across(ends_with(\"_mean\")))\n  )\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| sd_min| sd_max| mean_min| mean_max|\n|------:|------:|--------:|--------:|\n|      1|      1|        0|        0|\n\n</div>\n:::\n:::\n\n\nI'd like to assess whether the data contain meaningful clusters rather than random noise. This is achieved quantitatively by calculating the Hopkins statistic, and visually by inspection.\n\nIf the [Hopkins statistic](https://en.wikipedia.org/wiki/Hopkins_statistic) is closer to 1 than 0, then we have data which may be clustered.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_df |>\n  select(-mp) |>\n  get_clust_tendency(nrow(votes_df) - 1) |>\n  pluck(\"hopkins_stat\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.783357\n```\n:::\n:::\n\n\nA visual assessment of clustering tendency reveals distance data exhibiting a visible structure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_df |>\n  select(-mp) |>\n  dist() |>\n  fviz_dist(\n    show_labels = FALSE,\n    gradient = list(\n      low = cols[1],\n      mid = cols[3],\n      high = cols[4]\n    )\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/structure-1.png){width=100%}\n:::\n:::\n\n\nThere are eight methods I could use for [hierarchical clustering](https://en.wikipedia.org/wiki/Hierarchical_clustering), and I'll need to determine which will yield results that best fit the data.\n\nThe correlation plot below shows that the *median* and *ward* methods have a weaker correlation with the other five methods.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norig_dist <- scaled_df |>\n  select(-mp) |>\n  dist()\n\ndend_meths <-\n  c(\n    \"complete\",\n    \"average\",\n    \"single\",\n    \"ward.D\",\n    \"ward.D2\",\n    \"mcquitty\",\n    \"median\",\n    \"centroid\"\n  )\n\ndend_list <-\n  map(dend_meths, function(x) {\n    orig_dist |>\n      hclust(x) |>\n      as.dendrogram()\n  })\n\ndend_list |>\n  reduce(dendlist) |>\n  set_names(dend_meths) |>\n  cor.dendlist() |>\n  corrplot(\n    \"pie\",\n    \"lower\",\n    col = cols[1],\n    mar = c(1, 0.5, 4, 0.5),\n    order = \"AOE\",\n    tl.cex = 0.8,\n    tl.col = \"black\",\n    cl.cex = 0.7\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/cluster-1.png){width=100%}\n:::\n:::\n\n\nThe above plot does not tell us which method is optimal. For that, I'll take each of the cluster agglomeration methods and calculate their cophenetic distances. I can then correlate these with the original distance to see which offers the best fit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods <- list(\n  \"complete\",\n  \"average\",\n  \"single\",\n  \"ward.D\",\n  \"ward.D2\",\n  \"mcquitty\",\n  \"median\",\n  \"centroid\"\n)\n\nbest_method <- map_dfr(methods, function(x) {\n  co_comp <-\n    orig_dist |>\n    hclust(x) |>\n    cophenetic()\n  tibble(\n    correlation = cor(orig_dist, co_comp),\n    method = x\n  )\n})\n```\n:::\n\n\nThe plot below confirms the *ward* and *median* methods having a weaker fit. *Average* produces the strongest correlation coefficient of 0.98.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbest_method |>\n  ggplot(aes(reorder(method, correlation), correlation)) +\n  geom_col(fill = cols[1], width = 0.8) +\n  geom_text(aes(label = str_c(method, \"  \", round(correlation, 2))),\n    hjust = 1.3, colour = \"white\"\n  ) +\n  coord_flip() +\n  labs(\n    x = \"Method\", y = \"Correlation\",\n    title = \"Cluster Method Correlation Coefficients\",\n    caption = \"Source: Hansard\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/best-1.png){width=100%}\n:::\n:::\n\n\nI can now plot the full Labour Party dendrogram using the *average* method. This shows a \"cluster of six\" MPs which is the last to merge with the rest of the party based on their voting pattern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndend_avg <- orig_dist |>\n  hclust(\"average\") |>\n  as.dendrogram()\n\nlabels(dend_avg) <- scaled_df$mp[order.dendrogram(dend_avg)]\n\ndend <- dend_avg |>\n  color_branches(k = 2, col = cols[4]) |>\n  set(\"labels_cex\", 0.4)\n\nstart_formatted <- date_parse(start_date, format = \"%Y-%m-%d\") |> \n  date_format(format = \"%b %d, %Y\")\n\nend_formatted <- date_parse(end_date, format = \"%Y-%m-%d\") |> \n  date_format(format = \"%b %d, %Y\")\n\nggplot(rev(dend), horiz = TRUE, offset_labels = -0.2) +\n  labs(\n    y = \"\\nDistance\", title = \"Hierarchical Clustering of Labour MPs\",\n    subtitle = \"Based on House of Commons Divisions Since the 2017 Election\",\n    caption = glue(\n      \"Source: Hansard ({start_formatted} to {end_formatted})\")\n  ) +\n  theme(panel.border = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/dendogram-1.png){width=100%}\n:::\n:::\n\n\nI'll zoom in on the \"cluster of six\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndend_cuts <- dend |>\n  assign_values_to_leaves_nodePar(19, \"pch\") |>\n  assign_values_to_leaves_nodePar(5, \"cex\") |>\n  assign_values_to_leaves_nodePar(cols[1], \"col\") |>\n  set(\"labels_cex\", 0.4) |>\n  set(\"branches_lwd\", 2.5) |>\n  color_branches(k = 2, col = cols[1]) |>\n  cut(h = 50)\n\nggplot(rev(dend_cuts$lower[[1]]),\n  horiz = TRUE,\n  nodePar = nodePar,\n  offset_labels = -0.5\n) +\n  labs(\n    title = \"Cluster of Six\",\n    subtitle = \"MPs who Branch off First in the Dendrogram\"\n  ) +\n  theme_void() +\n  theme(plot.margin = unit(c(1, 1, 1, 1), \"cm\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/zoom-1.png){width=100%}\n:::\n:::\n\n\nSummarising and sorting the total votes by MP tells me that the \"cluster of six\" MPs are among the eight MPs voting the fewest times. And I can, for example, verify the record for Emma Reynolds directly via [*Hansard*](https://hansard.parliament.uk/search/MemberContributions?memberId=4077&startDate=2017-06-08&endDate=2018-01-27&type=Divisions&outputType=List).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfewest_votes <- votes |>\n  left_join(mps, by = c(\"mp\" = \"ID\")) |>\n  group_by(mp = full_name_value, lobby) |>\n  summarise(n_lobby = n()) |>\n  ungroup() |> \n  pivot_wider(names_from = \"lobby\", values_from = \"n_lobby\") |>\n  mutate(total = aye + no,\n         mp = fct_reorder(mp, total)) |>\n  slice_min(n = 10, order_by = total) |>\n  pivot_longer(cols = -mp) |>\n  filter(name != \"total\")\n\nfewest_votes |>\n  ggplot(aes(mp, value, fill = name)) +\n  geom_col() +\n  geom_label(aes(label = value), position = position_stack()) +\n  scale_fill_manual(values = cols[c(1, 3)]) +\n  coord_flip() +\n  labs(title = \"Labour MPs Voting Fewest Times\",\n       y = \"Votes\", x = NULL, fill = NULL)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fewest-1.png){width=100%}\n:::\n:::\n\n\nNon-voting will not be the only influencing factor. The \"distant cluster\" will be particularly influenced by a small minority of MPs voting in the opposite direction to the overwhelming majority.\n\n[*Cook's Distance*](https://en.wikipedia.org/wiki/Cook%27s_distance) visualises these influential outliers. This shows the voting of three MPs, all on the European Union Withdrawal Bill readings, to be particular outliers. All three MPs are in the \"cluster of six\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy_df <- votes_df |>\n  pivot_longer(cols = -mp, names_to = \"title\", values_to = \"vote\")\n\nmod <- lm(vote ~ ., data = tidy_df)\n\nmod_df <- mod |>\n  augment() |>\n  as_tibble()\n\nggplot(mod_df, aes(title, .cooksd, colour = mp)) +\n  geom_jitter() +\n  geom_label_repel(aes(label = if_else(.cooksd > 0.002, mp, NA)), size = 4) +\n  scale_colour_manual(values = wes_palette(220, name = \"Moonrise2\", type = \"continuous\")) +\n  labs(title = \"Cook's Distance\") +\n  coord_flip() +\n  theme(\n    panel.border = element_blank(),\n    axis.text = element_text(size = 6),\n    legend.position = \"none\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/cooks-1.png){width=100%}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_df |>\n  filter(str_detect(title, \"759161|824379|809989\")) |>\n  mutate(title = str_wrap(title, 30)) |> \n  ggplot(aes(title, .cooksd, colour = mp)) +\n  geom_point(size = 4) +\n  geom_label_repel(aes(label = if_else(.cooksd > 0.0015, mp, NA)), size = 4) +\n  ggtitle(\"Cook's Distance\") +\n  theme(\n    axis.line.x = element_line(color = \"grey60\"),\n    axis.text = element_text(size = 8),\n    legend.position = \"none\",\n    axis.title = element_blank()\n  ) +\n  scale_colour_manual(values = wes_palette(210, name = \"Moonrise2\", type = \"continuous\")) +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/six-1.png){width=100%}\n:::\n:::\n\n\n## R Toolbox\n\nSummarising below the packages and functions used in this post enables me to separately create a [toolbox visualisation](/project/box) summarising the usage of packages and functions across all posts.\n\n\n::: {.cell}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|Package     |Function                                                                                                                                                                                                                                                                                                                             |\n|:-----------|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n|base        |c[5];  conflicts[1];  cumsum[1];  cut[1];  function[4];  labels[1];  list[3];  max[2];  min[2];  nrow[1];  readRDS[2];  rev[2];  round[1];  saveRDS[2];  scale[1];  search[1];  sum[1]                                                                                                                                               |\n|broom       |augment[1]                                                                                                                                                                                                                                                                                                                           |\n|clock       |date_format[2];  date_parse[2]                                                                                                                                                                                                                                                                                                       |\n|corrplot    |corrplot[1]                                                                                                                                                                                                                                                                                                                          |\n|dendextend  |assign_values_to_leaves_nodePar[3];  color_branches[2];  cor.dendlist[1];  dendlist[1];  set[3]                                                                                                                                                                                                                                      |\n|dplyr       |ends_with[4];  filter[8];  across[2];  arrange[2];  c_across[4];  desc[2];  group_by[2];  if_else[6];  left_join[2];  mutate[9];  n[1];  rename[1];  select[5];  slice_min[1];  summarise[4];  transmute[1];  ungroup[1]                                                                                                             |\n|factoextra  |fviz_dist[1];  get_clust_tendency[1]                                                                                                                                                                                                                                                                                                 |\n|forcats     |fct_reorder[1]                                                                                                                                                                                                                                                                                                                       |\n|ggplot2     |aes[8];  coord_flip[4];  element_blank[3];  element_line[1];  element_text[2];  geom_col[2];  geom_jitter[1];  geom_label[1];  geom_point[1];  geom_text[1];  ggplot[6];  ggtitle[1];  labs[5];  position_stack[1];  scale_colour_manual[2];  scale_fill_manual[1];  theme[4];  theme_bw[1];  theme_set[1];  theme_void[1];  unit[1] |\n|ggrepel     |geom_label_repel[2]                                                                                                                                                                                                                                                                                                                  |\n|glue        |glue[1]                                                                                                                                                                                                                                                                                                                              |\n|hansard     |commons_members[1];  mp_vote_record[1]                                                                                                                                                                                                                                                                                               |\n|purrr       |compact[1];  map[3];  map2_dfr[1];  map_dfr[2];  pluck[1];  possibly[2];  reduce[1];  set_names[2]                                                                                                                                                                                                                                   |\n|readr       |read_lines[1]                                                                                                                                                                                                                                                                                                                        |\n|stats       |as.dendrogram[2];  cophenetic[1];  cor[1];  dist[2];  hclust[3];  lm[1];  reorder[1];  sd[1]                                                                                                                                                                                                                                         |\n|stringr     |str_c[9];  str_count[1];  str_detect[3];  str_remove[2];  str_remove_all[1];  str_replace[2];  str_starts[1];  str_wrap[1]                                                                                                                                                                                                           |\n|tibble      |as_tibble[2];  tibble[3];  tribble[1];  enframe[1]                                                                                                                                                                                                                                                                                   |\n|tidyr       |pivot_longer[2];  pivot_wider[2];  unnest[1]                                                                                                                                                                                                                                                                                         |\n|wesanderson |wes_palette[3]                                                                                                                                                                                                                                                                                                                       |\n\n</div>\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}