{
  "hash": "436944b91f52b2eb88fbbb970b224da4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Leaderboards: SportsRef\"\nauthor: \"Andrew Weatherman\"\ndate: \"2024-05-18\"\ncategories: [college basketball, scraping, tutorial, sports reference]\ndescription: \"Using `rvest` to scrape AP and Coaches polls from Sports Reference\"\n---\n\n\n## Introduction\n\nSports Reference includes a bevy of program, conference, and national leader data, but scraping it isn't *entirely* straightforward because the information is \"hidden\" behind expandable sections. Even so, we can use `rvest` to programmatically extract this data.\n\n::: {.callout-warning}\nSports Reference limits users to 20 requests per minute, so to avoid an HTTP 429 error (\"too many requests\"), all functions must use a sleep of three or more seconds -- `Sys.sleep(3)` -- when iterating over 20 times.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(rvest)\nlibrary(janitor)\nlibrary(rlang)\nlibrary(cbbdata)\n```\n:::\n\n\n\n## Structure\n\nThere are two structures to take note of here: program leaders and national/conference leaders.\n\n### Program Leaders\n\nScraping program leaderboards *is* fairly analogous to many other portions of the site: `html_table` works, but you need a little bit of cleaning.\n\n`html_table` will return *every* populated leaderboard (over 40), so we can use `html_text` and target the appropriate node to return the \"names\" of each statistical category. `rlang::set_names` can then take that vector and name our tables (the elements returned by `html_table`).\n\nIf we use `map2`, we can pass the name of each table to our cleaning function and set the third column, associated with the \"value\" of the record, to that name using `rename_with`.\n\nThere are three \"types\" of leaderboards offered: season, career, and game (usually complete to 2006-07). For the last one, there are two commas inside the player string, so we cannot use a comma delimiter to split player name and year/span/etc. So, we need to insert a different character (`|`) after the first comma and then split on that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscrape_program_leaders <- function(team, leaderboard_type) {\n  \n  slug <- filter(cbd_teams(), common_team == team) %>% \n    pull(sr_link) %>% \n    str_extract(\"(?<=schools/).+(?=/men)\") # extract slug\n  \n  url <- paste0('https://www.sports-reference.com/cbb/schools/', slug, '/men/leaders-and-records-', leaderboard_type, '.html')\n  \n  html <- read_html(url)\n  \n  # store names of tables\n  table_names <- html %>% html_nodes('#div_leaders .poptip') %>% html_text()\n  \n  # get the tables and set their names\n  tables <- html %>% html_table() %>% set_names(table_names)\n  \n  # set the delimiter based on leaderboard type\n  delim <- if(leaderboard_type == 'game') '|' else ','\n  \n  ## clean the tables\n  map2(tables, names(tables),\n      .f = function(table, name) {\n        \n        table %>% \n          # rename cols.\n          rename_with(~c('rank', 'player', name)) %>% \n          clean_names() %>% \n          # fix tied ranks\n          fill(rank, .direction = 'down') %>% \n          rowwise() %>% \n          mutate(player = ifelse(leaderboard_type == 'game',\n                                 gsub(\"^([^,]+),\\\\s*(.*)$\", \"\\\\1|\\\\2\", player),\n                                 player)) %>% \n          ungroup() %>% \n          # separate name and years played\n          separate_wider_delim(player, delim = delim, names = c('player', 'time')) %>% \n          # add team name\n          mutate(team = team, time = trimws(time))\n        \n      }\n    )\n  \n}\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nAPI Key set!\n```\n\n\n:::\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| rank|player             |time    | points|team |\n|----:|:------------------|:-------|------:|:----|\n|    1|J.J. Redick        |2005-06 |    964|Duke |\n|    2|R.J. Barrett       |2018-19 |    860|Duke |\n|    3|Jay Williams       |2000-01 |    841|Duke |\n|    4|Dick Groat         |1950-51 |    831|Duke |\n|    5|Johnny Dawkins     |1985-86 |    809|Duke |\n|    6|Danny Ferry        |1988-89 |    791|Duke |\n|    7|Dick Groat         |1951-52 |    780|Duke |\n|    8|Grayson Allen      |2015-16 |    779|Duke |\n|    9|Shane Battier      |2000-01 |    778|Duke |\n|   10|Christian Laettner |1990-91 |    771|Duke |\n\n</div>\n:::\n:::\n\n\n### National Leaders\n\nOn the other hand, national leaderboards are a bit more complex. If you run a simple `html_table` function on the leaderboard page, you'll be met with an empty list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_html('https://www.sports-reference.com/cbb/seasons/men/2024-leaders.html') %>% html_table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n:::\n\n\nTypically, this means one of two things: a) the page loads dynamically or b) there are no tables on the page...but neither are true! In fact, the data *is there* and *it is* wrapped in a traditional table. The data, however, is commented out *until* a user expands the table (image below), and `html_table` does not inherently access commented-out tables. So, what can we do?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](commented-out-tables.png){width=100%}\n:::\n:::\n\n\nWell, we need to access the *parent* ID of the tables, which in this case is `all_leaders` (and you can see that in the top right of the screenshot).\n\nOnce we do `html_nodes(#all_leaders)`, we need a way to access those commented-out tables, and we can do that using an `xpath` selector -- `comment()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_html('https://www.sports-reference.com/cbb/conferences/acc/men/2024-leaders.html') %>% \n  html_nodes('#all_leaders') %>% \n  html_nodes(xpath = \"comment()\")\n```\n:::\n\n\nIf you run that code, you'll be returned an XML nodeset element. Using that object, we can convert it to pure text with `html_text`, giving us the raw html string, and read it back into a usable format with `read_html`. *Finally*, we can toss in `html_table` to get the list of tables we expected at the start.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_html('https://www.sports-reference.com/cbb/conferences/acc/men/2024-leaders.html') %>% \n    html_nodes('#all_leaders') %>% \n    html_nodes(xpath = \"comment()\") %>% \n    html_text() %>% \n    read_html()\n```\n:::\n\n\nWhen cleaning, however, there is a small catch: Player and team names have no common delimiter like above. The *easiest* way to approach this, in my opinion, is to build the table manually by targeting the IDs of each column. The function below does this *and* sprinkles in the cleaning and naming described in the program section.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscrape_national_leaders <- function(year) {\n  \n  url <- paste0('https://www.sports-reference.com/cbb/seasons/men/', year, '-leaders.html')\n  \n  html <- read_html(url) %>% \n    html_nodes('#all_leaders') %>% \n    html_nodes(xpath = \"comment()\") %>% \n    html_text() %>% \n    read_html()\n  \n  # store names of tables\n  table_names <- html %>% html_nodes('#div_leaders .poptip') %>% html_text()\n  \n  # get the tables and set their names\n  tables <- html %>% html_nodes('table')\n  \n  ## clean the tables\n  all_tables <- map2(tables, table_names,\n     .f = function(table, name) {\n        data <- tibble(\n          rank = table %>% html_nodes('.rank') %>% html_text(),\n          player = table %>% html_nodes('a') %>% html_text(),\n          team = table %>% html_nodes('small') %>% html_text(),\n          value = table %>% html_nodes('.value') %>% html_text()\n        )\n        \n        data <- data %>% \n          mutate(rank = parse_number(rank),\n                 value = as.numeric(value)) %>% \n          fill(rank, .direction = 'down') %>% \n          rename_with(~c('rank', 'player', 'team', name)) %>% \n          clean_names()\n        \n        return(data)\n     }\n  )\n  \n  all_tables <- all_tables %>% set_names(table_names)\n  \n  return(all_tables)\n  \n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nscrape_national_leaders(2024)$Points\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| rank|player           |team            | points|\n|----:|:----------------|:---------------|------:|\n|    1|Zach Edey        |Purdue          |    983|\n|    2|Tommy Bruner     |Denver          |    816|\n|    3|Mark Sears       |Alabama         |    797|\n|    4|RJ Davis         |UNC             |    784|\n|    5|Dalton Knecht    |Tennessee       |    780|\n|    6|Jaedon Ledee     |San Diego State |    772|\n|    7|Jalen Blackmon   |Stetson         |    744|\n|    8|Tyler Thomas     |Hofstra         |    742|\n|    9|Terrence Shannon |Illinois        |    736|\n|   10|Tucker DeVries   |Drake           |    734|\n\n</div>\n:::\n:::\n\n\n### Conference Leaders\n\nConference leaderboards behave similarly to national ones, and I'll leave that as an exercise for the reader (at least for now).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}